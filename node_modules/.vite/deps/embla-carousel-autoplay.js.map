{
  "version": 3,
  "sources": ["../../embla-carousel-autoplay/src/components/Options.ts", "../../embla-carousel-autoplay/src/components/Autoplay.ts"],
  "sourcesContent": ["import { CreateOptionsType } from 'embla-carousel/components/Options'\n\nexport type OptionsType = CreateOptionsType<{\n  delay: number\n  jump: boolean\n  playOnInit: boolean\n  stopOnFocusIn: boolean\n  stopOnInteraction: boolean\n  stopOnMouseEnter: boolean\n  stopOnLastSnap: boolean\n  rootNode: ((emblaRoot: HTMLElement) => HTMLElement | null) | null\n}>\n\nexport const defaultOptions: OptionsType = {\n  active: true,\n  breakpoints: {},\n  delay: 4000,\n  jump: false,\n  playOnInit: true,\n  stopOnFocusIn: true,\n  stopOnInteraction: true,\n  stopOnMouseEnter: false,\n  stopOnLastSnap: false,\n  rootNode: null\n}\n", "import { OptionsType, defaultOptions } from './Options'\nimport { CreatePluginType } from 'embla-carousel/components/Plugins'\nimport { OptionsHandlerType } from 'embla-carousel/components/OptionsHandler'\nimport { EmblaCarouselType } from 'embla-carousel'\n\ndeclare module 'embla-carousel/components/Plugins' {\n  interface EmblaPluginsType {\n    autoplay?: AutoplayType\n  }\n}\n\ndeclare module 'embla-carousel/components/EventHandler' {\n  interface EmblaEventListType {\n    autoplayPlay: 'autoplay:play'\n    autoplayStop: 'autoplay:stop'\n  }\n}\n\nexport type AutoplayType = CreatePluginType<\n  {\n    play: (jump?: boolean) => void\n    stop: () => void\n    reset: () => void\n    isPlaying: () => boolean\n  },\n  OptionsType\n>\n\nexport type AutoplayOptionsType = AutoplayType['options']\n\nfunction Autoplay(userOptions: AutoplayOptionsType = {}): AutoplayType {\n  let options: OptionsType\n  let emblaApi: EmblaCarouselType\n  let destroyed: boolean\n  let playing = false\n  let resume = true\n  let jump = false\n  let animationFrame = 0\n  let timer = 0\n\n  function init(\n    emblaApiInstance: EmblaCarouselType,\n    optionsHandler: OptionsHandlerType\n  ): void {\n    emblaApi = emblaApiInstance\n\n    const { mergeOptions, optionsAtMedia } = optionsHandler\n    const optionsBase = mergeOptions(defaultOptions, Autoplay.globalOptions)\n    const allOptions = mergeOptions(optionsBase, userOptions)\n    options = optionsAtMedia(allOptions)\n\n    if (emblaApi.scrollSnapList().length <= 1) return\n\n    jump = options.jump\n    destroyed = false\n\n    const { eventStore, ownerDocument } = emblaApi.internalEngine()\n    const emblaRoot = emblaApi.rootNode()\n    const root = (options.rootNode && options.rootNode(emblaRoot)) || emblaRoot\n    const container = emblaApi.containerNode()\n\n    emblaApi.on('pointerDown', stopTimer)\n\n    if (!options.stopOnInteraction) {\n      emblaApi.on('pointerUp', startTimer)\n    }\n\n    if (options.stopOnMouseEnter) {\n      eventStore.add(root, 'mouseenter', () => {\n        resume = false\n        stopTimer()\n      })\n\n      if (!options.stopOnInteraction) {\n        eventStore.add(root, 'mouseleave', () => {\n          resume = true\n          startTimer()\n        })\n      }\n    }\n\n    if (options.stopOnFocusIn) {\n      eventStore.add(container, 'focusin', stopTimer)\n\n      if (!options.stopOnInteraction) {\n        eventStore.add(container, 'focusout', startTimer)\n      }\n    }\n\n    eventStore.add(ownerDocument, 'visibilitychange', visibilityChange)\n\n    if (options.playOnInit) {\n      emblaApi.on('init', startTimer).on('reInit', startTimer)\n    }\n  }\n\n  function destroy(): void {\n    emblaApi\n      .off('init', startTimer)\n      .off('reInit', startTimer)\n      .off('pointerDown', stopTimer)\n      .off('pointerUp', startTimer)\n    stopTimer()\n    cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n    destroyed = true\n    playing = false\n  }\n\n  function startTimer(): void {\n    if (destroyed) return\n    if (!resume) return\n    if (!playing) emblaApi.emit('autoplay:play')\n    const { ownerWindow } = emblaApi.internalEngine()\n    ownerWindow.clearInterval(timer)\n    timer = ownerWindow.setInterval(next, options.delay)\n    playing = true\n  }\n\n  function stopTimer(): void {\n    if (destroyed) return\n    if (playing) emblaApi.emit('autoplay:stop')\n    const { ownerWindow } = emblaApi.internalEngine()\n    ownerWindow.clearInterval(timer)\n    timer = 0\n    playing = false\n  }\n\n  function visibilityChange(): void {\n    const { ownerDocument } = emblaApi.internalEngine()\n\n    if (ownerDocument.visibilityState === 'hidden') {\n      resume = playing\n      return stopTimer()\n    }\n\n    if (resume) startTimer()\n  }\n\n  function play(jumpOverride?: boolean): void {\n    if (typeof jumpOverride !== 'undefined') jump = jumpOverride\n    resume = true\n    startTimer()\n  }\n\n  function stop(): void {\n    if (playing) stopTimer()\n  }\n\n  function reset(): void {\n    if (playing) play()\n  }\n\n  function isPlaying(): boolean {\n    return playing\n  }\n\n  function next(): void {\n    animationFrame = requestAnimationFrame(() => {\n      const { index } = emblaApi.internalEngine()\n      const nextIndex = index.clone().add(1).get()\n      const lastIndex = emblaApi.scrollSnapList().length - 1\n      const kill = options.stopOnLastSnap && nextIndex === lastIndex\n\n      if (kill) stopTimer()\n\n      if (emblaApi.canScrollNext()) {\n        emblaApi.scrollNext(jump)\n      } else {\n        emblaApi.scrollTo(0, jump)\n      }\n    })\n  }\n\n  const self: AutoplayType = {\n    name: 'autoplay',\n    options: userOptions,\n    init,\n    destroy,\n    play,\n    stop,\n    reset,\n    isPlaying\n  }\n  return self\n}\n\nAutoplay.globalOptions = <AutoplayOptionsType | undefined>undefined\n\nexport default Autoplay\n"],
  "mappings": "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",
  "names": ["defaultOptions", "active", "breakpoints", "delay", "jump", "playOnInit", "stopOnFocusIn", "stopOnInteraction", "stopOnMouseEnter", "stopOnLastSnap", "rootNode", "Autoplay", "userOptions", "options", "emblaApi", "destroyed", "playing", "resume", "animationFrame", "timer", "init", "emblaApiInstance", "optionsHandler", "mergeOptions", "optionsAtMedia", "optionsBase", "globalOptions", "allOptions", "scrollSnapList", "length", "eventStore", "ownerDocument", "internalEngine", "emblaRoot", "root", "container", "containerNode", "on", "stopTimer", "startTimer", "add", "visibilityChange", "destroy", "off", "cancelAnimationFrame", "emit", "ownerWindow", "clearInterval", "setInterval", "next", "visibilityState", "play", "jumpOverride", "stop", "reset", "isPlaying", "requestAnimationFrame", "index", "nextIndex", "clone", "get", "lastIndex", "kill", "canScrollNext", "scrollNext", "scrollTo", "self", "name", "undefined"]
}
